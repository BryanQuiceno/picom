#include <libconfig.h>
#include <uthash.h>
#include "compiler.h"        // IWYU pragma: keep
#include "transition/script.h"
#include "transition/script_internal.h"
#include "utils/dynarr.h"
#include "wm/win.h"

struct placeholder {
	UT_hash_handle hh;
	const char *name;
	unsigned index;
	double default_value;
};

// `config_setting_lookup_*` surprisingly doesn't support paths like
// `config_setting_lookup` does. e.g. indexing like `[0]` is not supported. So we define
// our own helper functions here.

bool config_extra_lookup_int(config_setting_t *setting, const char *path, int *value) {
	auto sub = config_setting_lookup(setting, path);
	if (!sub) {
		return false;
	}
	if (config_setting_type(sub) != CONFIG_TYPE_INT) {
		return false;
	}
	*value = config_setting_get_int(sub);
	return true;
}

bool config_extra_lookup_float(config_setting_t *setting, const char *path, double *value) {
	auto sub = config_setting_lookup(setting, path);
	if (!sub) {
		return false;
	}
	if (config_setting_type(sub) != CONFIG_TYPE_FLOAT) {
		return false;
	}
	*value = config_setting_get_float(sub);
	return true;
}

char *sanitized_name(const char *name) {
	char *ret = strdup(name);
	for (char *p = ret; *p; p++) {
		if (*p == '-') {
			*p = '_';
		}
	}
	return ret;
}

void codegen(const char *name, const char *body, const struct placeholder *placeholders) {
	auto ident = sanitized_name(name);
	printf("static struct script *script_template__%s(int *output_slots)\n%s\n",
	       ident, body);
	printf("static bool win_script_preset__%s(struct win_script *output, "
	       "config_setting_t *setting) {\n",
	       ident);
	printf("    output->script = script_template__%s(output->output_indices);\n", ident);
	for (size_t i = 0; i < 10; i++) {
		if (placeholders[i].name) {
			auto placeholder_ident = sanitized_name(placeholders[i].name);
			printf("    double placeholder_%s = %f;\n", placeholder_ident,
			       placeholders[i].default_value);
			printf("    config_setting_lookup_float(setting, \"%s\", "
			       "&placeholder_%s);\n",
			       placeholders[i].name, placeholder_ident);
			free(placeholder_ident);
		}
	}
	printf("    struct script_specialization_context spec[] = {\n");
	for (size_t i = 0; i < 10; i++) {
		if (placeholders[i].name) {
			auto placeholder_ident = sanitized_name(placeholders[i].name);
			printf("        {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + %zu, "
			       ".value = placeholder_%s},\n",
			       i * 4, placeholder_ident);
			free(placeholder_ident);
		}
	}
	printf("    };\n");
	printf("    script_specialize(output->script, spec, ARR_SIZE(spec));\n");
	printf("    return true;\n");
	printf("}\n");
	free(ident);
}

int main(int argc, const char **argv) {
	if (argc != 2) {
		return 1;
	}

	log_init_tls();

	char **presets = dynarr_new(char *, 10);

	config_t cfg;
	config_init(&cfg);
	config_set_auto_convert(&cfg, 1);

	config_read_file(&cfg, argv[1]);

	auto settings = config_root_setting(&cfg);

	// win_script_context_info and 10 extra placeholder contexts, for
	// script_specialize()
	static const ptrdiff_t base = SCRIPT_CTX_PLACEHOLDER_BASE;
	struct script_context_info context_info[ARR_SIZE(win_script_context_info) + 10] = {
	    {"placeholder0", base},      {"placeholder1", base + 4},
	    {"placeholder2", base + 8},  {"placeholder3", base + 12},
	    {"placeholder4", base + 16}, {"placeholder5", base + 20},
	    {"placeholder6", base + 24}, {"placeholder7", base + 28},
	    {"placeholder8", base + 32}, {"placeholder9", base + 36},
	};
	memcpy(context_info + 10, win_script_context_info, sizeof(win_script_context_info));

	struct script_output_info outputs[ARR_SIZE(win_script_outputs)];
	memcpy(outputs, win_script_outputs, sizeof(win_script_outputs));

	struct script_parse_config parse_config = {
	    .context_info = context_info,
	    .output_info = NULL,
	};
	printf("// This file is generated by tools/animgen.c from %s\n", argv[1]);
	printf("// This file is included in git repository for convenience only.\n");
	printf("// DO NOT EDIT THIS FILE!\n\n");

	printf("#include <libconfig.h>\n");
	printf("#include \"../script.h\"\n");
	printf("#include \"../curve.h\"\n");
	printf("#include \"../script_internal.h\"\n");
	printf("#include \"utils/misc.h\"\n");
	printf("#include \"config.h\"\n");
	for (unsigned i = 0; i < (unsigned)config_setting_length(settings); i++) {
		auto sub = config_setting_get_elem(settings, i);
		auto name = config_setting_name(sub);
		struct placeholder *placeholders_by_name = NULL;
		struct placeholder placeholders[10] = {};

		auto placeholders_config = config_setting_get_member(sub, "placeholders");
		if (placeholders_config) {
			for (unsigned j = 0;
			     j < (unsigned)config_setting_length(placeholders_config); j++) {
				auto placeholder_config =
				    config_setting_get_elem(placeholders_config, j);
				const char *placeholder_name =
				    config_setting_name(placeholder_config);
				if (!config_setting_is_list(placeholder_config) ||
				    config_setting_length(placeholder_config) != 2) {
					fprintf(stderr,
					        "Invalid placeholder %s in %s, line %d. "
					        "It must be a list of 2 numbers.\n",
					        placeholder_name, name,
					        config_setting_source_line(placeholder_config));
					continue;
				}

				int index;
				double default_value;
				if (!config_extra_lookup_int(placeholder_config, "[0]", &index) ||
				    !config_extra_lookup_float(placeholder_config, "[1]",
				                               &default_value)) {
					fprintf(stderr,
					        "Invalid placeholder %s in %s, line %d. "
					        "Failed to get elements.\n",
					        placeholder_name, name,
					        config_setting_source_line(placeholder_config));
					continue;
				}
				if (index < 0 || (size_t)index >= ARR_SIZE(placeholders)) {
					fprintf(
					    stderr, "Invalid placeholder index %d in %s, line %d\n",
					    index, name,
					    config_setting_source_line(placeholder_config));
					continue;
				}
				struct placeholder *placeholder =
				    malloc(sizeof(*placeholder));
				placeholder->name = strdup(placeholder_name);
				placeholder->index = (unsigned)index;
				placeholder->default_value = default_value;
				HASH_ADD_STR(placeholders_by_name, name, placeholder);

				placeholders[index] = *placeholder;
			}
			config_setting_remove(sub, "placeholders");
			placeholders_config = NULL;
		}

		char *err = NULL;
		auto script = script_compile(sub, parse_config, &err);
		if (!script) {
			fprintf(stderr, "Failed to compile script %s: %s\n", name, err);
			free(err);
			continue;
		}
		bool has_err = false;
		for (size_t j = 0; j < script->len; j++) {
			if (script->instrs[j].type != INST_LOAD_CTX) {
				continue;
			}
			if (script->instrs[j].ctx >= base) {
				size_t index = ((size_t)script->instrs[j].ctx - base) / 4;
				BUG_ON(index >= ARR_SIZE(placeholders));
				if (!placeholders[index].name) {
					fprintf(stderr,
					        "Placeholder %zu used, but not defined\n",
					        index);
					has_err = true;
					break;
				}
			}
		}

		if (!has_err) {
			char *code = script_to_c(script, outputs);
			codegen(name, code, placeholders);
			free(code);

			dynarr_push(presets, strdup(name));
		}
		struct placeholder *p, *np;
		HASH_ITER(hh, placeholders_by_name, p, np) {
			free((void *)p->name);
			HASH_DEL(placeholders_by_name, p);
			free(p);
		}
		script_free(script);
	}

	config_destroy(&cfg);

	printf("struct {\n"
	       "    const char *name;\n"
	       "    bool (*func)(struct win_script *output, config_setting_t *setting);\n"
	       "} win_script_presets[] = {\n");
	dynarr_foreach(presets, p) {
		auto ident = sanitized_name(*p);
		printf("    {\"%s\", win_script_preset__%s},\n", *p, ident);
		free(*p);
		free(ident);
	}
	printf("    {NULL, NULL},\n};\n");
	dynarr_free_pod(presets);
	return 0;
}
